# Supabase CRUD Operations Implementation Guide

This guide provides step-by-step instructions for implementing Create, Read, Update, and Soft-Delete (CRUD) operations for a new entity using Supabase as the data store.

## Overview

CRUD operations with Supabase leverage PostgreSQL's powerful features. This guide covers:
- **Create**: Inserting new records using Supabase client
- **Read**: Retrieving records with Supabase queries and filtering
- **Update**: Modifying existing records with Supabase updates
- **Soft-Delete**: Marking records as deleted without permanent removal

## Prerequisites

Before implementing CRUD operations, ensure you have:
1. Supabase client configured (`@supabase/supabase-js`)
2. Database tables created in Supabase
3. Entity TypeScript interfaces defined
4. Table naming convention with prefix established
5. Basic project structure set up

## Step 1: Define the Entity Interface

Create a TypeScript interface that describes the entity's structure:

```typescript
interface EntityName {
  id: string;
  // Add other required fields based on your requirements
  created_at: string; // ISO timestamp string (Supabase standard)
  updated_at: string;
  deleted_at?: string; // For soft-delete support (ISO timestamp)
}

// Input types for operations
interface CreateEntityInput {
  // Define fields required for creation (excluding id, timestamps)
}

interface UpdateEntityInput {
  // Define fields that can be updated (partial)
}
```

## Step 2: Establish Database Table and Types

Define consistent table naming and TypeScript types for your entity:

```typescript
// Table naming with prefix support
const TABLE_PREFIX = process.env.SUPABASE_TABLE_PREFIX || '';

function getTableName(table: string): string {
  return `${TABLE_PREFIX}${table}`;
}

// Table names
const ENTITIES_TABLE = getTableName('entities');

// Database row type (matches Supabase table structure)
interface EntityRow {
  id: string;
  // Add your entity fields here
  created_at: string;
  updated_at: string;
  deleted_at?: string;
}

// Query filters
interface EntityFilters {
  // Define filterable fields
  status?: string;
  category?: string;
  // Add other filter fields
}

// Pagination options
interface PaginationOptions {
  page: number;
  limit: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}
```

## Step 3: Implement Create Operation

### Step 3.1: Define Input Validation

Create a schema for validating create input:

```typescript
import { z } from 'zod';

const createEntitySchema = z.object({
  // Define validation schema based on entity fields
  name: z.string().min(1).max(100),
  description: z.string().optional(),
  status: z.enum(['active', 'inactive']).default('active'),
});

type CreateEntityInput = z.infer<typeof createEntitySchema>;
```

### Step 3.2: Implement Create Method

```typescript
import { supabaseAdmin } from './supabase-admin';

async function createEntity(input: CreateEntityInput): Promise<EntityName> {
  // Validate input
  const validatedData = createEntitySchema.parse(input);

  // Insert into Supabase (ID is auto-generated by Supabase)
  const { data, error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .insert([{
      ...validatedData,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    }])
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to create entity: ${error.message}`);
  }

  return data as EntityName;
}
```

## Step 4: Implement Read Operations

### Step 4.1: Find by ID

```typescript
async function getEntityById(id: string): Promise<EntityName | null> {
  const { data, error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*')
    .eq('id', id)
    .is('deleted_at', null) // Only get non-deleted entities
    .single();

  if (error) {
    if (error.code === 'PGRST116') { // No rows returned
      return null;
    }
    throw new Error(`Failed to get entity: ${error.message}`);
  }

  return data as EntityName;
}
```

### Step 4.2: Find All with Pagination

```typescript
async function getEntities(options: PaginationOptions): Promise<{
  data: EntityName[];
  total: number;
  page: number;
  totalPages: number;
}> {
  const { page, limit, sortBy = 'created_at', sortOrder = 'desc' } = options;
  const offset = (page - 1) * limit;

  // Get total count
  const { count: totalCount, error: countError } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*', { count: 'exact', head: true })
    .is('deleted_at', null);

  if (countError) {
    throw new Error(`Failed to get entity count: ${countError.message}`);
  }

  // Get paginated data
  let query = supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*')
    .is('deleted_at', null)
    .range(offset, offset + limit - 1);

  // Add sorting
  if (sortOrder === 'desc') {
    query = query.order(sortBy, { ascending: false });
  } else {
    query = query.order(sortBy, { ascending: true });
  }

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to get entities: ${error.message}`);
  }

  return {
    data: data as EntityName[],
    total: totalCount || 0,
    page,
    totalPages: Math.ceil((totalCount || 0) / limit),
  };
}
```

### Step 4.3: Find with Filters

```typescript
async function getEntitiesWithFilters(filters: EntityFilters): Promise<EntityName[]> {
  let query = supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*')
    .is('deleted_at', null);

  // Apply filters
  if (filters.status) {
    query = query.eq('status', filters.status);
  }

  if (filters.category) {
    query = query.eq('category', filters.category);
  }

  // Add more filters as needed
  Object.entries(filters).forEach(([key, value]) => {
    if (value !== undefined && value !== null && !['status', 'category'].includes(key)) {
      query = query.eq(key, value);
    }
  });

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to get filtered entities: ${error.message}`);
  }

  return data as EntityName[];
}
```

### Step 4.4: Advanced Filtering with Supabase

```typescript
// Supabase automatically handles indexing for common queries
// For better performance, ensure proper indexes are created in your database

async function getEntitiesByStatus(status: string): Promise<EntityName[]> {
  const { data, error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*')
    .eq('status', status)
    .is('deleted_at', null);

  if (error) {
    throw new Error(`Failed to get entities by status: ${error.message}`);
  }

  return data as EntityName[];
}

// Complex queries with multiple filters
async function searchEntities(searchTerm: string, filters: EntityFilters = {}): Promise<EntityName[]> {
  let query = supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*')
    .is('deleted_at', null)
    .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`);

  // Apply additional filters
  if (filters.status) {
    query = query.eq('status', filters.status);
  }

  const { data, error } = await query;

  if (error) {
    throw new Error(`Failed to search entities: ${error.message}`);
  }

  return data as EntityName[];
}
```

## Step 5: Implement Update Operation

### Step 5.1: Define Update Validation

```typescript
const updateEntitySchema = createEntitySchema.partial();

type UpdateEntityInput = z.infer<typeof updateEntitySchema>;
```

### Step 5.2: Implement Update Method

```typescript
async function updateEntity(id: string, input: UpdateEntityInput): Promise<EntityName> {
  // Validate input
  const validatedData = updateEntitySchema.parse(input);

  // Check if entity exists and is not deleted
  const existingEntity = await getEntityById(id);
  if (!existingEntity) {
    throw new Error('Entity not found');
  }

  // Update in Supabase
  const { data, error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .update({
      ...validatedData,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to update entity: ${error.message}`);
  }

  return data as EntityName;
}
```

## Step 6: Implement Soft-Delete Operation

### Step 6.1: Soft Delete Method

```typescript
async function softDeleteEntity(id: string): Promise<EntityName> {
  // Check if entity exists and is not already deleted
  const existingEntity = await getEntityById(id);
  if (!existingEntity) {
    throw new Error('Entity not found');
  }

  if (existingEntity.deleted_at) {
    throw new Error('Entity is already deleted');
  }

  // Mark as soft-deleted in Supabase
  const { data, error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .update({
      deleted_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to soft delete entity: ${error.message}`);
  }

  return data as EntityName;
}
```

### Step 6.2: Restore Soft-Deleted Entity (Optional)

```typescript
async function restoreEntity(id: string): Promise<EntityName> {
  // Check if entity exists and is deleted
  const { data: existingEntity, error: fetchError } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .select('*')
    .eq('id', id)
    .not('deleted_at', 'is', null)
    .single();

  if (fetchError || !existingEntity) {
    throw new Error('Entity not found or not deleted');
  }

  // Restore by setting deleted_at to null
  const { data, error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .update({
      deleted_at: null,
      updated_at: new Date().toISOString(),
    })
    .eq('id', id)
    .select()
    .single();

  if (error) {
    throw new Error(`Failed to restore entity: ${error.message}`);
  }

  return data as EntityName;
}
```

### Step 6.3: Permanently Delete (Optional - Use with Caution)

```typescript
async function hardDeleteEntity(id: string): Promise<void> {
  // Permanently delete from Supabase
  const { error } = await supabaseAdmin
    .from(ENTITIES_TABLE)
    .delete()
    .eq('id', id);

  if (error) {
    throw new Error(`Failed to hard delete entity: ${error.message}`);
  }
}
```

## Step 7: Add API Routes/Controllers

Create RESTful API endpoints for the CRUD operations:

```typescript
// pages/api/entities/index.ts - Create and Read all
import { NextApiRequest, NextApiResponse } from 'next';
import { createEntity, getEntities } from '../../../lib/entity-service';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method === 'POST') {
    try {
      const entity = await createEntity(req.body);
      res.status(201).json(entity);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  } else if (req.method === 'GET') {
    try {
      const { page = 1, limit = 10, sortBy, sortOrder, ...filters } = req.query;
      const result = await getEntities({
        page: Number(page),
        limit: Number(limit),
        sortBy: sortBy as string,
        sortOrder: sortOrder as 'asc' | 'desc',
        filters,
      });
      res.json(result);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  } else {
    res.setHeader('Allow', ['GET', 'POST']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}

// pages/api/entities/[id].ts - Read, Update, Delete by ID
import { NextApiRequest, NextApiResponse } from 'next';
import { getEntityById, updateEntity, softDeleteEntity } from '../../../lib/entity-service';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  const { id } = req.query;

  if (req.method === 'GET') {
    try {
      const entity = await getEntityById(id as string);
      if (!entity) {
        return res.status(404).json({ error: 'Entity not found' });
      }
      res.json(entity);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  } else if (req.method === 'PUT') {
    try {
      const entity = await updateEntity(id as string, req.body);
      res.json(entity);
    } catch (error) {
      if (error.message === 'Entity not found') {
        res.status(404).json({ error: error.message });
      } else {
        res.status(400).json({ error: error.message });
      }
    }
  } else if (req.method === 'DELETE') {
    try {
      await softDeleteEntity(id as string);
      res.status(204).send();
    } catch (error) {
      if (error.message === 'Entity not found') {
        res.status(404).json({ error: error.message });
      } else {
        res.status(500).json({ error: error.message });
      }
    }
  } else {
    res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);
    res.status(405).end(`Method ${req.method} Not Allowed`);
  }
}
```

## Step 8: Add Error Handling and Validation Middleware

```typescript
// Middleware for input validation
const validateCreateEntity = (req, res, next) => {
  try {
    createEntitySchema.parse(req.body);
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid input', details: error.errors });
  }
};

const validateUpdateEntity = (req, res, next) => {
  try {
    updateEntitySchema.parse(req.body);
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid input', details: error.errors });
  }
};

// Middleware for entity existence check
const checkEntityExists = async (req, res, next) => {
  try {
    const entity = await getEntityById(req.params.id);
    if (!entity) {
      return res.status(404).json({ error: 'Entity not found' });
    }
    req.entity = entity; // Attach entity to request for later use
    next();
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};
```

## Supabase-Specific Considerations

### Database Schema Design

- **Tables**: Use PostgreSQL tables with proper constraints and indexes
- **Row Level Security (RLS)**: Enable RLS for multi-tenant applications
- **Indexes**: Create indexes on frequently queried columns
- **UUIDs**: Use UUIDs for primary keys (Supabase auto-generates them)

### Table Naming Conventions

```sql
-- Consistent table naming with prefixes
CREATE TABLE your_prefix_entities (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'active' CHECK (status IN ('active', 'inactive')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  deleted_at TIMESTAMP WITH TIME ZONE
);

-- Create indexes for performance
CREATE INDEX idx_entities_status ON your_prefix_entities(status) WHERE deleted_at IS NULL;
CREATE INDEX idx_entities_created_at ON your_prefix_entities(created_at DESC) WHERE deleted_at IS NULL;
```

### Database Connection

```typescript
// Supabase handles connection pooling and error handling automatically
// Configure connection limits in your Supabase project settings
```

### Handling Supabase Connection Issues

```typescript
// Supabase client handles connection issues automatically
// Implement retry logic for transient errors
async function withRetry<T>(operation: () => Promise<T>, maxRetries = 3): Promise<T> {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
    }
  }
  throw new Error('Max retries exceeded');
}
```

## Supabase Best Practices

1. **Use Row Level Security (RLS)**: Enable RLS for data access control and multi-tenancy
2. **Implement Proper Indexing**: Create indexes on frequently queried and filtered columns
3. **Use Transactions**: Wrap multi-step operations in database transactions
4. **Implement Pagination**: Use Supabase's built-in pagination for large datasets
5. **Handle Rate Limiting**: Supabase has rate limits, implement client-side throttling
6. **Use Database Constraints**: Leverage PostgreSQL constraints for data integrity
7. **Implement Audit Logging**: Use Supabase triggers for audit trails
8. **Monitor Query Performance**: Use Supabase dashboard to monitor slow queries
9. **Implement Connection Pooling**: Supabase handles this automatically
10. **Use Environment Variables**: Keep connection details secure
11. **Implement Health Checks**: Monitor database connectivity
12. **Add Metrics**: Track query performance and error rates
13. **Plan for Scaling**: Supabase handles scaling automatically
14. **Use Database Views**: Create views for complex queries
15. **Implement Data Validation**: Use database constraints and application validation
16. **Handle Timeouts**: Set appropriate timeouts for long-running queries
17. **Use Database Functions**: Leverage PostgreSQL functions for complex operations
18. **Implement Backup Strategy**: Supabase provides automated backups

### Service Layer Pattern

```typescript
class EntityService {
  constructor(private supabaseClient: any) {}

  async createEntity(input: CreateEntityInput): Promise<EntityName> {
    // Business logic, validation, etc.
    const validatedData = createEntitySchema.parse(input);

    const { data, error } = await this.supabaseClient
      .from(ENTITIES_TABLE)
      .insert([validatedData])
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  // Other methods...
}
```

This implementation provides a solid foundation for CRUD operations using Supabase that can be adapted to specific entity requirements and scaled as needed.